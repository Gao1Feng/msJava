# 动态代理是如何实现？

动态代理的常用实现方式是反射。反射机制是指程序在运行期间可以访问、检测和修改其本身状态或行为的一种能力，使用反射我们可以调用任意一个类对象，以及类对象中包含的属性及方法。

# JDK Proxy 和 CGLib 有什么区别？

1. JDK Proxy 是 Java 语言自带的功能，无需通过加载第三方类实现；
2. Java 对 JDK Proxy 提供了稳定的支持，并且会持续的升级和更新 JDK Proxy，例如 Java 8 版本中的 JDK Proxy 性能相比于之前版本提升了很多；
3. JDK Proxy 是通过拦截器加反射的方式实现的；
4. JDK Proxy 只能代理继承接口的类；
5. JDK Proxy 实现和调用起来比较简单；
6. CGLib 是第三方提供的工具，基于 ASM 实现的，性能比较高；
7. CGLib 无需通过接口来实现，它是通过实现子类的方式来完成调用的。

# 动态代理与静态代理区别
- **静态代理**

  > 由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 

  **静态代理类优缺点** 

​      **优点**：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。
​      **缺点**：代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规     模稍大时就无法胜任了。 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。

- **动态代理**

  > 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。 

  **动态代理类优缺点** 

  - **优点：**动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似Spring AOP那样配置外围业务。 
  - **缺点：**诚然，Proxy 已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，原因是多继承在 Java 中本质上就行不通。 
