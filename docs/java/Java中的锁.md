# Java中的锁

> Java中的锁主要是用于保障线程在并发情况下数据一致性。
>
> + 乐观锁与悲观锁
> + 公平锁与非公平锁
> + 共享锁与独占锁
> + 偏向锁、轻量级锁和重量级锁
> + 自旋锁

## 1. 乐观锁

​       **乐观锁**采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改数据，所以不会加锁，但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号，然后加锁的方法。

​       具体过程如下：比较当前版本号与上一次的版本号，如果版本号相同，则更新，否则重复进行读、比较、写操作。

​       Java中的乐观锁大部分是通过CAS（比较和交换）操作实现的，CAS是一种原子更新操作，在对数据操作之前首先会比较当前值跟传入的值是否一致，如果一致则更新，否则不更新，直接返回失败。

## 2. 悲观锁

​       **悲观锁**采用悲观的思想处理数据，在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会加锁，这样别人想读写当前数据时就会被阻塞，等待直到获取锁。

​       Java中的悲观锁大部分基于AQS(抽象的队列同步器)架构实现。该框架下的锁会先尝试以CAS乐观锁去获取锁，如果失败，则会转为悲观锁。

## 3. synchronized关键字

​       **synchronized**关键字用于Java对象、方法、代码块提供线程安全的操作。synchronized独占式的悲观锁，也属于可重入锁（可重入锁也叫递归锁，指在同一线程中，在外层函数获取到该锁之后，内层的递归函数仍然可以继续获取该锁。）。

​       在synchronized修饰对象时，同一时刻只能有一个线程对对象进行访问；

​       在synchronized修饰方法、代码块时，同一时刻只能有一个线程执行该方法体或者代码块，其他线程只有等待当前线程执行完毕并释放资源后才能访问该对象或执行同步代码块。

​       

