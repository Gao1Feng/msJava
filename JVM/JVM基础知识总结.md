1. JVM内存区域

> JVM内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区），线程共享区域（堆内存、方法区）和直接内存。

+ 程序计数器

程序计数器是一块很小的内存空间，用于存储当前运行的线程所执行的字节码的行号指令，每个运行中的线程都有一个独立的程序计数器，在方法正在执行时，该方法的程序计数器记录的是实时虚拟机字节码指令的地址；如果该方法执行的是Native方法，则程序计数器的值为空。

+ 虚拟机栈

虚拟机栈是描述Java方法的执行过程的内存模型，它在当前栈帧存储了局部变量表、操作数栈、动态链接、方法出口等信息。同时，栈帧用来存储部分运行时数据及其数据结构，处理动态链接方法的返回值和异常分派。

+ 本地方法区

本地方法区和虚拟机栈作用类似，区别就是本地方法栈是为Native方法服务，而虚拟机栈是为了Java方法服务。

+ 堆内存

在JVM运行过程中创建的对象和产生的数据都被存储在堆中，堆是被线程共享的内存区域，也是垃圾收集器进行垃圾回首的最主要的内存区域。

+ 方法区

方法区用于存储常量、静态变量、类信息、即时编译器编译后的机器码、运行时常量等数据。

## 2. 如何确定垃圾

+ 引用计数法

在Java中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为一个对象添加一个引用时，引用计数器就加1；为对象删除一个引用时，引用计数器就减1；如果一个对象的引用计数为0，则说明该对象没有被引用，可以回收。**优点是垃圾回收比较及时，实时性比较高，只要对象计数器为 0，则可以直接进行回收操作；而缺点是无法解决循环引用的问题。**

+ 可达性分析

以一系列GC ROOTS的点作为起点向下搜索，当一个对象到任何GC ROOTS都没有引用链相连时，说明该对象可以回收。

![img](https://s0.lgstatic.com/i/image/M00/14/70/Ciqc1F7Q3giAKu5UAAClt3UMheE300.png)

在 Java 中可以作为 CG Roots 的对象，主要包含以下几个：
所有被同步锁持有的对象，比如被 synchronize 持有的对象；
字符串常量池里的引用（String Table）；
类型为引用类型的静态变量；
虚拟机栈中引用对象；
本地方法栈中的引用对象。

## 3.常用垃圾回收算法

+ 标记清除算法 ；会引起内存碎片化问题，继而引起大对象无法获得连续可用内存空间的问题。

<img src="https://s0.lgstatic.com/i/image/M00/14/7B/CgqCHl7Q3hOAHBq0AABM8DvzlGU761.png" alt="img" style="zoom:50%;" />

+ 复制算法；可用的内存空间被压缩一半，导致内存浪费。

  <img src="https://s0.lgstatic.com/i/image/M00/14/7B/CgqCHl7Q3h6ATzDEAABQETkptLk639.png" alt="img" style="zoom: 50%;" />

+ 标记整理算法；结合了标记清除算法和复制算法的优点。

  <img src="https://s0.lgstatic.com/i/image/M00/14/7B/CgqCHl7Q3ieAYV5FAABLfGQH4UE403.png" alt="image (7).png" style="zoom:50%;" />

+ 分代收集算法；新生代采用复制算法，老年代采用标记清除算法。

## 4. 垃圾回收器

+ 新生代
  + Serial(单线程复制算法)
  + ParNew(多线程复制算法)
  + Parallel Scavenge(多线程复制算法)
  
+ 老年代
  + CMS(多线程标记清除算法)
  + Serial Old(单线程标记整理算法)
  + Parallel Old(多线程标记整理算法)

   G1(多线程标记整理算法)
  
  ![image (2).png](https://s0.lgstatic.com/i/image/M00/17/58/CgqCHl7XFo-AYbIbAABPIp2dreY362.png)


## 5. 类加载流程
类的生命周期会经历以下 7 个阶段：

- 加载阶段（Loading）

  此阶段用于查到相应的类（通过类名进行查找）并将此类的字节流转换为方法区运行时的数据结构，然后再在内存中生成一个能代表此类的 java.lang.Class 对象，作为其他数据访问的入口。

  > 小贴士：需要注意的是加载阶段和连接阶段的部分动作有可能是交叉执行的，比如一部分字节码文件格式的验证，在加载阶段还未完成时就已经开始验证了。

- 验证阶段

此步骤主要是为了验证字节码的安全性，如果不做安全校验的话可能会载入非安全或有错误的字节码，从而导致系统崩溃，它是 JVM 自我保护的一项重要举措。

验证的主要动作大概有以下几个：

1. 文件格式校验包括常量池中的常量类型、Class 文件的各个部分是否被删除或被追加了其他信息等；
2. 元数据校验包括父类正确性校验（检查父类是否有被 final 修饰）、抽象类校验等；
3. 字节码校验，此步骤最为关键和复杂，主要用于校验程序中的语义是否合法且符合逻辑；
4. 符号引用校验，对类自身以外比如常量池中的各种符号引用的信息进行匹配性校验。

+ 准备阶段

此阶段是用来初始化并为类中定义的静态变量分配内存的，这些静态变量会被分配到方法区上。

HotSpot 虚拟机在 JDK 1.7 之前都在方法区，而 JDK 1.8 之后此变量会随着类对象一起存放到 Java 堆中。

- 解析阶段

此阶段主要是用来解析类、接口、字段及方法的，解析时会把符号引用替换成直接引用。

所谓的符号引用是指以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可；而直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

符号引用和直接引用有一个重要的区别：使用符号引用时被引用的目标不一定已经加载到内存中；而使用直接引用时，引用的目标必定已经存在虚拟机的内存中了。

- 初始化

初始化阶段 JVM 就正式开始执行类中编写的 Java 业务代码了。到这一步骤之后，类的加载过程就算正式完成了。

## 6. 总结

 **JVM 的内存布局主要分为：堆、方法区、程序计数器、虚拟机栈和本地方法栈，并讲了 JVM 的执行流程，先把 Java 代码编译成字节码，再把字节码加载到运行时数据区；然后交给 JVM 引擎把字节码翻译为操作系统可以执行的指令进行执行；最后还讲了类加载的 5 个阶段：加载、验证、准备、解析和初始化。**



