# JVM基础知识总结

## 1. JVM内存区域

> JVM内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区），线程共享区域（堆内存、方法区）和直接内存。

+ 程序计数器

程序计数器是一块很小的内存空间，用于存储当前运行的线程所执行的字节码的行号指令，每个运行中的线程都有一个独立的程序计数器，在方法正在执行时，该方法的程序计数器记录的是实时虚拟机字节码指令的地址；如果该方法执行的是Native方法，则程序计数器的值为空。

+ 虚拟机栈

虚拟机栈是描述Java方法的执行过程的内存模型，它在当前栈帧存储了局部变量表、操作数栈、动态链接、方法出口等信息。同时，栈帧用来存储部分运行时数据及其数据结构，处理动态链接方法的返回值和异常分派。

+ 本地方法区

本地方法区和虚拟机栈作用类似，区别就是本地方法栈是为Native方法服务，而虚拟机栈是为了Java方法服务。

+ 堆内存

在JVM运行过程中创建的对象和产生的数据都被存储在堆中，堆是被线程共享的内存区域，也是垃圾收集器进行垃圾回首的最主要的内存区域。

+ 方法区

方法区用于存储常量、静态变量、类信息、即时编译器编译后的机器码、运行时常量等数据。

## 2. 如何确定垃圾

+ 引用计数法

在Java中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为一个对象添加一个引用时，引用计数器就加1；为对象删除一个引用时，引用计数器就减1；如果一个对象的引用计数为0，则说明该对象没有被引用，可以回收。**缺点：无法解决循环引用的问题。**

+ 可达性分析

以一系列GC ROOTS的点作为起点向下搜索，当一个对象到任何GC ROOTS都没有引用链相连时，说明该对象可以回收。

在 Java 中可以作为 CG Roots 的对象，主要包含以下几个：
所有被同步锁持有的对象，比如被 synchronize 持有的对象；
字符串常量池里的引用（String Table）；
类型为引用类型的静态变量；
虚拟机栈中引用对象；
本地方法栈中的引用对象。

## 3.常用垃圾回收算法

+ 标记清除算法 ；会引起内存碎片化问题，继而引起大对象无法获得连续可用内存空间的问题。
+ 复制算法；可用的内存空间被压缩一半，导致内存浪费。
+ 标记整理算法；结合了标记清除算法和复制算法的优点。
+ 分代收集算法；新生代采用复制算法，老年代采用标记清除算法。

## 4. 垃圾回收器

+ 新生代
  + Serial(单线程复制算法)
  + ParNew(多线程复制算法)
  + Parallel Scavenge(多线程复制算法)
+ 老年代
  + CMS(多线程标记清除算法)
  + Serial Old(单线程标记整理算法)
  + Parallel Old(多线程标记整理算法)

   G1(多线程标记整理算法)


## 5. 类加载流程
类的生命周期会经历以下 7 个阶段：

加载阶段（Loading）
连接(Linking)
  验证阶段（Verification）
  准备阶段（Preparation）
  解析阶段（Resolution）
初始化阶段（Initialization）
使用阶段（Using）
卸载阶段（Unloading）


​    

​    

