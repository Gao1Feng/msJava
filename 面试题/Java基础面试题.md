# Java基础面试题

### **“String、StringBuffer、StringBulider”的区别是什么？**

1.可变性。String不可变，StringBuffer与StringBulider可变。

+ String类是使用字符祖保存字符串，private final char value[]，所有不可变的（Java9中底层把char数组换成了byte数组，占用更少的空间。
+ StringBulider与StringBuffer都继承自AbstractStringBulider类，在AbstractStringBulider中也是使用字符串组保存字符串，char[] value，这两种对象都是可变的。

2.线程安全。StringBulider是非线程安全的，String和StringBuffer是线程安全的。

+ String线程安全是因为其对象不可变，StringBuffer线程安全是因为对方法加了同步锁或者调用的方法加了同步锁。
+ StringBulider并没有对方法进行加同步锁，所以是非线程安全的。

3.性能方面。

+ String的性能较差，每次对String类型进行改变的时候，都会生成一个新的String对象，然后将引用指向新的String对象。
+ 而StringBulider、StringBuffer性能更高，是因为每次都是对对象本身进行操作，而不是生成新的对象并改变对象引用。

###　**抽象类和接口有什么异同？**

1.相同点

+ 不能直接实例化。如果要实例化，抽象类变量必须实现所有抽象方法，接口变量必须实现所有接口未实现的方法。
+ 都可以有实现方法（Java8以前的接口是不能有实现方法的）。
+ 都可以不需要实现类或者继承者去实现所有方法。

2.不同点

+ 抽象类和接口的设计理念不同。抽象类表示的是对象、类的抽象，接口表示的是对行为的抽象。
+ 接口可以多继承，抽象类不可以多继承。即一个类只能继承一个抽象类，却可以继承多个接口。
+ 接口没有构造器，抽象类可以有构造器。
+ 访问修饰符不同
  + 抽象类中的方法可以用public protected和default abstract 修饰符，不能有private、static、synchronize、native修饰；变量可以在子类中重新定义，也可以重新赋值。
  + 接口的方法默认修饰符是public abstract，Java8开始出现静态方法，多加static关键字；变量默认是public static final型，且必须给其初始值，在其实现类中也不能重新定义，也不能修改。

###　**Java创建对象的方式有哪些？**

1. 使用new关键字；
2. 反射，使用java.lang.Class类的newInstance方法；
3. 反射，使用java.lang.reflect.Constructor类的newInstance方法。

4. 使用clone方法。实现Cloneable接口且实现clone方法。

5. 使用反序列化。

### **什么是浅拷贝和深拷贝？**

1. 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，对拷贝后对象的引用仍然指向原来的对象。
2. 深拷贝：不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。

### Java中IO流分为几种？

**按功能：**输入流、输出流。

**按类型：** 字节流、字符流。

**按区别：** 字节流按8位传输以字节为单位输入输出数据，字符流按16位传输以字符为单位输入输出数据。

### 创建线程有哪几种方式？

1. 继承Thread类重写run()方法；
2. 实现Runnable接口重写run()方法；
3. 实现Callable接口重写call()方法；

### sleep()和wait()有什么区别？

1. sleep()来自Thread类，wait()来自Object()类；
2. sleep()不释放锁，wait()释放锁；
3. sleep()到时间会自动恢复，wait()不会，但可以使用notify()或notifyAll()直接唤醒；

### ThreadLocal是什么？ 有哪些使用场景？

ThreadLocal为每个使用该变量的线程提高独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。

ThreadLocal的常用使用场景是数据库的连接和session的管理等。

### synchronized和volatile的区别是什么？

1. volatile是变量修饰复，synchronized可以修饰类、方法、代码块；
2. volatile只能够保证变量修改的可见性，不能保证原子性。而synchronized则可以保证变量的修改可见性和原子性；
3. volatile不会造成线程的阻塞。synchronized可能会造成线程的阻塞。

###　synchronized和Lock的区别是什么？

1. synchronized可以给类、方法、代码块等加锁。Lock只能给代码块加锁。
2. synchronized不需要手动释放锁和获取锁，使用简单，如果发生异常会自动释放锁，不会造成死锁。Lock需要自己加锁和释放锁，如果使用不当没有释放锁会造成死锁。
3. 通过Lock可以知道有没有成功获取锁，而synchronized却没法做到。

### 什么是序列化？什么情况下需要序列化?

**序列化是为了保证各种对象在内存中的状态，并且可以把保存的对象再读出来。**

**需要序列化的情况如下：**

1. 想把内存中的对象状态保存到一个文件中或者数据库中的时候。
2. 想用套接字在网络上传送对象的时候。
3. 想通过RMI传输对象的时候。

### Java当中的四种引用分别指什么？

**强引用,软引用,弱引用,虚引用**。

**不同的引用类型主要体现在GC上：**

1. **强引用**，如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象；
2. **软引用**，在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收；
3. **弱引用**，具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象；
4. **虚引用**，顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收；

### Java内部类有什么作用？

内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.

创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体。内部类提供了更好的封装,除了该外围类,其他类都不能访问

### HashSet如何检查重复？

当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。



****

